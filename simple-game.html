<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simple Endless Runner - Obstacle Test</title>
    <style>
        body { 
            margin: 0; 
            padding: 20px; 
            font-family: Arial, sans-serif; 
            background: #333; 
            color: white; 
        }
        canvas { 
            border: 2px solid #fff; 
            display: block; 
            margin: 20px auto; 
            background: #87CEEB; 
        }
        .controls { 
            text-align: center; 
            margin: 20px; 
        }
        button { 
            padding: 10px 20px; 
            margin: 5px; 
            font-size: 16px; 
        }
        .info { 
            background: #222; 
            padding: 20px; 
            margin: 20px; 
            border-radius: 5px; 
        }
        .game-header {
            text-align: center;
            margin: 20px;
            font-size: 18px;
        }
    </style>
</head>
<body>
    <h1>Simple Endless Runner - Obstacle Test</h1>
    
    <div class="game-header">
        <span>Score: <span id="currentScore">0</span></span> | 
        <span>Distance: <span id="currentDistance">0</span>m</span>
    </div>
    
    <div class="controls">
        <button onclick="startGame()">Start Game</button>
        <button onclick="stopGame()">Stop Game</button>
        <button onclick="resetGame()">Reset Game</button>
    </div>
    
    <canvas id="gameCanvas" width="800" height="400"></canvas>
    
    <div class="info">
        <h3>Instructions:</h3>
        <p>• Click "Start Game" to begin</p>
        <p>• Use Space or Arrow Up to jump over obstacles</p>
        <p>• Obstacles should appear as red rectangles moving from right to left</p>
        <p>• Check the console for debug information</p>
        <p>• This is a simplified version to test the obstacle system</p>
    </div>

    <script>
        // Simplified Game Class - Focus on Obstacles
        class SimpleGame {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.gameRunning = false;
                this.animationId = null;
                this.lastTime = 0;
                
                this.score = 0;
                this.distance = 0;
                this.gameSpeed = 5;
                this.maxSpeed = 15;
                
                this.init();
            }
            
            init() {
                console.log('Initializing SimpleGame');
                this.setupCanvas();
                this.initGameObjects();
                this.setupControls();
            }
            
            setupCanvas() {
                this.canvas.width = 800;
                this.canvas.height = 400;
                console.log('Canvas setup - Width:', this.canvas.width, 'Height:', this.canvas.height);
            }
            
            initGameObjects() {
                // Player
                this.player = {
                    x: 100,
                    y: this.canvas.height - 100,
                    width: 40,
                    height: 60,
                    velocityY: 0,
                    isJumping: false
                };

                // Ground
                this.ground = {
                    y: this.canvas.height - 40,
                    height: 40
                };

                // Obstacles
                this.obstacles = [];
                this.obstacleTypes = [
                    { width: 50, height: 100, y: this.ground.y - 100 }, // High obstacle
                    { width: 100, height: 50, y: this.ground.y - 50 }  // Low obstacle
                ];

                // Add initial obstacles
                this.addInitialObstacles();

                // Background elements - increased speed for better movement
                this.backgrounds = [
                    { x: 0, y: 0, width: this.canvas.width, height: this.canvas.height, speed: 3 },
                    { x: 0, y: this.ground.y - 100, width: this.canvas.width, height: 100, speed: 4 },
                    { x: this.canvas.width, y: this.ground.y - 150, width: 200, height: 50, speed: 5 },
                    { x: this.canvas.width + 300, y: this.ground.y - 120, width: 150, height: 70, speed: 5 }
                ];

                // Game physics
                this.gravity = 0.8;
                this.jumpPower = -15;
            }
            
            addInitialObstacles() {
                // Add 2-3 initial obstacles to start the game
                for (let i = 0; i < 3; i++) {
                    const obstacleType = this.obstacleTypes[Math.floor(Math.random() * this.obstacleTypes.length)];
                    const obstacle = {
                        x: this.canvas.width + (i * 300) + 100, // Space them out but closer to screen
                        y: obstacleType.y,
                        width: obstacleType.width,
                        height: obstacleType.height
                    };
                    this.obstacles.push(obstacle);
                    console.log(`Initial obstacle ${i + 1}:`, obstacle);
                }
                console.log('Initial obstacles added:', this.obstacles.length);
                console.log('Canvas width:', this.canvas.width);
            }
            
            setupControls() {
                document.addEventListener('keydown', (e) => {
                    if (this.gameRunning) {
                        switch(e.code) {
                            case 'Space':
                            case 'ArrowUp':
                                e.preventDefault();
                                this.jump();
                                break;
                        }
                    }
                });
            }
            
            jump() {
                if (!this.player.isJumping) {
                    this.player.isJumping = true;
                    this.player.velocityY = this.jumpPower;
                }
            }
            
            start() {
                this.gameRunning = true;
                this.lastTime = performance.now();
                this.gameLoop();
            }
            
            stop() {
                this.gameRunning = false;
                if (this.animationId) {
                    cancelAnimationFrame(this.animationId);
                    this.animationId = null;
                }
            }
            
            gameLoop(currentTime) {
                if (!this.gameRunning) return;

                const deltaTime = currentTime - this.lastTime;
                this.lastTime = currentTime;

                this.update(deltaTime);
                this.render();

                this.animationId = requestAnimationFrame((time) => this.gameLoop(time));
            }
            
            update(deltaTime) {
                // Update player physics
                this.updatePlayer(deltaTime);
                
                // Update obstacles
                this.updateObstacles(deltaTime);
                
                // Update backgrounds
                this.updateBackgrounds(deltaTime);
                
                // Check collisions
                this.checkCollisions();
                
                // Spawn new obstacles
                this.spawnObstacles();
                
                // Update game stats
                this.updateDistance(this.distance + this.gameSpeed * (deltaTime / 1000));
                
                // Debug logging every 60 frames (about once per second)
                if (Math.random() < 0.016) { // 1/60 chance
                    console.log('Game state - Obstacles:', this.obstacles.length, 'Speed:', this.gameSpeed);
                }
            }
            
            updatePlayer(deltaTime) {
                // Apply gravity
                if (this.player.isJumping) {
                    this.player.velocityY += this.gravity;
                    this.player.y += this.player.velocityY;
                    
                    // Check if landed
                    if (this.player.y >= this.ground.y - this.player.height) {
                        this.player.y = this.ground.y - this.player.height;
                        this.player.isJumping = false;
                        this.player.velocityY = 0;
                    }
                }
            }
            
            updateObstacles(deltaTime) {
                for (let i = this.obstacles.length - 1; i >= 0; i--) {
                    const obstacle = this.obstacles[i];
                    obstacle.x -= this.gameSpeed;
                    
                    // Debug logging for obstacle positions
                    if (i === 0) { // Log first obstacle position
                        console.log('First obstacle x:', obstacle.x, 'Canvas width:', this.canvas.width);
                    }
                    
                    // Remove obstacles that are completely off screen (with some buffer)
                    if (obstacle.x + obstacle.width < -50) {
                        this.obstacles.splice(i, 1);
                        this.updateScore(10); // Bonus points for avoiding
                        console.log('Obstacle removed, remaining:', this.obstacles.length);
                    }
                }
            }
            
            updateBackgrounds(deltaTime) {
                this.backgrounds.forEach(bg => {
                    bg.x -= bg.speed;
                    if (bg.x + bg.width <= 0) {
                        bg.x = this.canvas.width;
                    }
                });
            }
            
            spawnObstacles() {
                // Spawn obstacles more frequently and reliably
                const minSpawnDistance = 300; // Minimum distance between obstacles
                
                if (this.obstacles.length === 0 || 
                    this.obstacles[this.obstacles.length - 1].x < this.canvas.width - minSpawnDistance) {
                    
                    const obstacleType = this.obstacleTypes[Math.floor(Math.random() * this.obstacleTypes.length)];
                    const obstacle = {
                        x: this.canvas.width + 50, // Spawn slightly off-screen to the right
                        y: obstacleType.y,
                        width: obstacleType.width,
                        height: obstacleType.height
                    };
                    
                    this.obstacles.push(obstacle);
                    
                    // Debug logging
                    console.log('Obstacle spawned:', obstacle);
                    console.log('Total obstacles:', this.obstacles.length);
                }
            }
            
            checkCollisions() {
                const playerBounds = {
                    x: this.player.x,
                    y: this.player.y,
                    width: this.player.width,
                    height: this.player.height
                };

                this.obstacles.forEach(obstacle => {
                    if (this.isColliding(playerBounds, obstacle)) {
                        this.gameOver();
                    }
                });
            }
            
            isColliding(rect1, rect2) {
                return rect1.x < rect2.x + rect2.width &&
                       rect1.x + rect1.width > rect2.x &&
                       rect1.y < rect2.y + rect2.height &&
                       rect1.y + rect1.height > rect2.y;
            }
            
            updateScore(points) {
                this.score += points;
                document.getElementById('currentScore').textContent = this.score;
            }
            
            updateDistance(meters) {
                this.distance = Math.floor(meters);
                document.getElementById('currentDistance').textContent = this.distance;
                
                // Increase game speed over time
                if (this.gameSpeed < this.maxSpeed) {
                    this.gameSpeed = 5 + (this.distance / 100) * 2;
                }
            }
            
            gameOver() {
                this.stop();
                alert(`Game Over! Score: ${this.score}, Distance: ${this.distance}m`);
            }
            
            render() {
                // Clear canvas
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                
                // Draw background
                this.drawBackground();
                
                // Draw ground
                this.drawGround();
                
                // Draw obstacles
                this.drawObstacles();
                
                // Draw player
                this.drawPlayer();
                
                // Debug info on screen
                this.drawDebugInfo();
            }
            
            drawDebugInfo() {
                this.ctx.fillStyle = '#FFFFFF';
                this.ctx.font = '16px Arial';
                this.ctx.textAlign = 'left';
                this.ctx.fillText(`Obstacles: ${this.obstacles.length}`, 10, 30);
                this.ctx.fillText(`Game Speed: ${this.gameSpeed}`, 10, 50);
                this.ctx.fillText(`Canvas: ${this.canvas.width}x${this.canvas.height}`, 10, 70);
                
                if (this.obstacles.length > 0) {
                    this.ctx.fillText(`First obstacle at: (${Math.round(this.obstacles[0].x)}, ${Math.round(this.obstacles[0].y)})`, 10, 90);
                }
            }
            
            drawBackground() {
                // Sky gradient
                const gradient = this.ctx.createLinearGradient(0, 0, 0, this.canvas.height);
                gradient.addColorStop(0, '#87CEEB');
                gradient.addColorStop(1, '#98FB98');
                
                this.ctx.fillStyle = gradient;
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                
                // Draw background elements with more visibility
                this.backgrounds.forEach((bg, index) => {
                    if (index === 0) {
                        // Main background layer - subtle
                        this.ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
                    } else {
                        // Additional background elements - more visible
                        this.ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
                    }
                    this.ctx.fillRect(bg.x, bg.y, bg.width, bg.height);
                    
                    // Add some cloud-like shapes for visual interest
                    if (index >= 2) {
                        this.ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
                        this.ctx.beginPath();
                        this.ctx.arc(bg.x + bg.width/2, bg.y + bg.height/2, bg.height/3, 0, Math.PI * 2);
                        this.ctx.fill();
                    }
                });
            }
            
            drawGround() {
                this.ctx.fillStyle = '#8B4513';
                this.ctx.fillRect(0, this.ground.y, this.canvas.width, this.ground.height);
                
                // Ground texture
                this.ctx.strokeStyle = '#654321';
                this.ctx.lineWidth = 2;
                for (let x = 0; x < this.canvas.width; x += 50) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(x, this.ground.y);
                    this.ctx.lineTo(x, this.ground.y + this.ground.height);
                    this.ctx.stroke();
                }
            }
            
            drawObstacles() {
                // Only log every 60 frames to avoid spam
                if (Math.random() < 0.016) {
                    console.log('Drawing obstacles, count:', this.obstacles.length);
                }
                
                if (this.obstacles.length === 0) {
                    console.log('No obstacles to draw!');
                    return;
                }
                
                this.obstacles.forEach((obstacle, index) => {
                    // Draw shadow first
                    this.ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                    this.ctx.fillRect(obstacle.x + 3, obstacle.y + 3, obstacle.width, obstacle.height);
                    
                    // Main obstacle body with gradient
                    const gradient = this.ctx.createLinearGradient(obstacle.x, obstacle.y, obstacle.x + obstacle.width, obstacle.y + obstacle.height);
                    gradient.addColorStop(0, '#FF4444');
                    gradient.addColorStop(1, '#CC0000');
                    this.ctx.fillStyle = gradient;
                    this.ctx.fillRect(obstacle.x, obstacle.y, obstacle.width, obstacle.height);
                    
                    // Obstacle outline
                    this.ctx.strokeStyle = '#880000';
                    this.ctx.lineWidth = 4;
                    this.ctx.strokeRect(obstacle.x, obstacle.y, obstacle.width, obstacle.height);
                    
                    // Inner highlight
                    this.ctx.strokeStyle = '#FF6666';
                    this.ctx.lineWidth = 2;
                    this.ctx.strokeRect(obstacle.x + 2, obstacle.y + 2, obstacle.width - 4, obstacle.height - 4);
                    
                    // Add obstacle number for debugging
                    this.ctx.fillStyle = '#FFFFFF';
                    this.ctx.font = 'bold 20px Arial';
                    this.ctx.textAlign = 'center';
                    this.ctx.fillText(`${index + 1}`, obstacle.x + obstacle.width/2, obstacle.y + obstacle.height/2 + 7);
                    
                    // Add some texture/detail
                    this.ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
                    this.ctx.fillRect(obstacle.x + 5, obstacle.y + 5, obstacle.width - 10, 3);
                    this.ctx.fillRect(obstacle.x + 5, obstacle.y + obstacle.height - 8, obstacle.width - 10, 3);
                });
            }
            
            drawPlayer() {
                // Player body
                this.ctx.fillStyle = '#4CAF50';
                this.ctx.fillRect(this.player.x, this.player.y, this.player.width, this.player.height);
                
                // Player outline
                this.ctx.strokeStyle = '#2E7D32';
                this.ctx.lineWidth = 2;
                this.ctx.strokeRect(this.player.x, this.player.y, this.player.width, this.player.height);
                
                // Player details
                this.ctx.fillStyle = '#FFD700';
                this.ctx.fillRect(this.player.x + 5, this.player.y + 5, 10, 10); // Eye
                this.ctx.fillRect(this.player.x + 25, this.player.y + 5, 10, 10); // Eye
                
                // Arms and legs
                this.ctx.fillStyle = '#4CAF50';
                this.ctx.fillRect(this.player.x - 5, this.player.y + 10, 5, 20); // Left arm
                this.ctx.fillRect(this.player.x + this.player.width, this.player.y + 10, 5, 20); // Right arm
                this.ctx.fillRect(this.player.x + 5, this.player.y + this.player.height, 8, 15); // Left leg
                this.ctx.fillRect(this.player.x + 27, this.player.y + this.player.height, 8, 15); // Right leg
            }
        }
        
        let game = new SimpleGame();
        
        function startGame() {
            game.start();
        }
        
        function stopGame() {
            game.stop();
        }
        
        function resetGame() {
            game.stop();
            game = new SimpleGame();
        }
    </script>
</body>
</html>
